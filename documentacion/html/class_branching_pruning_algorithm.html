<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Maximum diversity problem: BranchingPruningAlgorithm Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Maximum diversity problem
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_branching_pruning_algorithm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_branching_pruning_algorithm-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BranchingPruningAlgorithm Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Representa una clase que va a aplicar el algoritmo de expansion y poda.  
 <a href="class_branching_pruning_algorithm.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="branching-pruning-algorithm_8hpp_source.html">branching-pruning-algorithm.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BranchingPruningAlgorithm:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_branching_pruning_algorithm.png" usemap="#BranchingPruningAlgorithm_map" alt=""/>
  <map id="BranchingPruningAlgorithm_map" name="BranchingPruningAlgorithm_map">
<area href="class_algorithm.html" title="Representa una clase que va a permitir aplicar el patrón estrategia." alt="Algorithm" shape="rect" coords="0,0,167,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af5dd885c99c56c7e841e947d3a5042da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_branching_pruning_algorithm.html#af5dd885c99c56c7e841e947d3a5042da">BranchingPruningAlgorithm</a> (std::string newName, int m, <a class="el" href="class_solution.html">Solution</a> alg, bool mode)</td></tr>
<tr class="memdesc:af5dd885c99c56c7e841e947d3a5042da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construye el algoritmo de ramificación y poda con un nombre, un valor m que representa el tamaño de la solucióm, una solución inicial de la que va a partir el algoritmo y un booleano que indica cual va a la función de exploración (cota mínima o profundidad).  <a href="class_branching_pruning_algorithm.html#af5dd885c99c56c7e841e947d3a5042da">More...</a><br /></td></tr>
<tr class="separator:af5dd885c99c56c7e841e947d3a5042da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f5de69f9f03aaf35267d17d454d0bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_branching_pruning_algorithm.html#a46f5de69f9f03aaf35267d17d454d0bd">initializeTree</a> ()</td></tr>
<tr class="memdesc:a46f5de69f9f03aaf35267d17d454d0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Este método se encarga de inicializar el árbol, para ello se centra en crear los nodos que se encuentran en el primer nivel del arbol, añadiendolos al árbol.  <a href="class_branching_pruning_algorithm.html#a46f5de69f9f03aaf35267d17d454d0bd">More...</a><br /></td></tr>
<tr class="separator:a46f5de69f9f03aaf35267d17d454d0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9157bf2cff571f8dbfa6c794e880979"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_branching_pruning_algorithm.html#ab9157bf2cff571f8dbfa6c794e880979">getUpperBound</a> (std::vector&lt; int &gt; solution)</td></tr>
<tr class="memdesc:ab9157bf2cff571f8dbfa6c794e880979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Esta función se encarga de determinar la cota superior, para ello hay que tener en cuenta, que UPB2 va a formarse a partir de las p mejores aristas que est ́an entre sel y unsel y UPB3 van a ser las mejores aristas de unsel y unsel. Con esto en mente, sabemos que nuestra cota superior va a ser la suma de UPB2 Y UPB3.  <a href="class_branching_pruning_algorithm.html#ab9157bf2cff571f8dbfa6c794e880979">More...</a><br /></td></tr>
<tr class="separator:ab9157bf2cff571f8dbfa6c794e880979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5f31dfc1eb79130f55a7ca708380a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_branching_pruning_algorithm.html#a0c5f31dfc1eb79130f55a7ca708380a8">expand</a> (int position)</td></tr>
<tr class="memdesc:a0c5f31dfc1eb79130f55a7ca708380a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funcion que se encarga de expandir el nodo que se ha seleccionado, para ello, pone el mismo a visitado y se pasa a generar los nodos hijos del mismo (teniendo en cuenta que partimos de la idea de que se ha implementado un arbol mejorado, es decir, impide que hayan nodos duplicados), creando cada nodo y añadiendolo al arbol.  <a href="class_branching_pruning_algorithm.html#a0c5f31dfc1eb79130f55a7ca708380a8">More...</a><br /></td></tr>
<tr class="separator:a0c5f31dfc1eb79130f55a7ca708380a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252084974f86d1aadd4b916508a77d73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_branching_pruning_algorithm.html#a252084974f86d1aadd4b916508a77d73">getMin</a> ()</td></tr>
<tr class="memdesc:a252084974f86d1aadd4b916508a77d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funcion que se encarga de determinar cual es el siguiente nodo a escoger para luego expandir, en el caso de que se den las condiciones. Depende de la función de exploración asignada, se hará con cota mínima o por profundidad.  <a href="class_branching_pruning_algorithm.html#a252084974f86d1aadd4b916508a77d73">More...</a><br /></td></tr>
<tr class="separator:a252084974f86d1aadd4b916508a77d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80a8fba560dc660dd19925a7c83dadb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_solution.html">Solution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_branching_pruning_algorithm.html#ad80a8fba560dc660dd19925a7c83dadb">run</a> ()</td></tr>
<tr class="memdesc:ad80a8fba560dc660dd19925a7c83dadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Función principal del algoritmo, esta se encarga de asignar la cota inferior al valor de la distancia de la solución inicial, inicializar el arbol e iterar en un bucle que se haya recorrido todo el árbol, en cada iteracion se determina el nodo con el menor valor y este se comprueba si mejora la solución, en caso de que lo haga y no esté visitado se expande. Si con la solución parcial actual, el valor de la distancia es superior a la cota inferior esta se actualiza. Además si se ha llegado al tamaño de la solución indicado se almacena dicha solución y retorna.  <a href="class_branching_pruning_algorithm.html#ad80a8fba560dc660dd19925a7c83dadb">More...</a><br /></td></tr>
<tr class="separator:ad80a8fba560dc660dd19925a7c83dadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_algorithm"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_algorithm')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_algorithm.html">Algorithm</a></td></tr>
<tr class="memitem:a472bdce2086324f49da7794e27ccaa54 inherit pub_methods_class_algorithm"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm.html#a472bdce2086324f49da7794e27ccaa54">Algorithm</a> ()</td></tr>
<tr class="separator:a472bdce2086324f49da7794e27ccaa54 inherit pub_methods_class_algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671b9c245fc5d9e49ca942372e03febc inherit pub_methods_class_algorithm"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm.html#a671b9c245fc5d9e49ca942372e03febc">setInfo</a> (<a class="el" href="class_vectors.html">Vectors</a> newVector)</td></tr>
<tr class="memdesc:a671b9c245fc5d9e49ca942372e03febc inherit pub_methods_class_algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Se encarga de inicializar la información recogida del fichero, es decir, los vectores y asignarlos al atributo de la clase que lo va a almacenar.  <a href="class_algorithm.html#a671b9c245fc5d9e49ca942372e03febc">More...</a><br /></td></tr>
<tr class="separator:a671b9c245fc5d9e49ca942372e03febc inherit pub_methods_class_algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db7703ee0d4177478259e6f41d69549 inherit pub_methods_class_algorithm"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm.html#a2db7703ee0d4177478259e6f41d69549">getTotalDistance</a> (std::vector&lt; int &gt; solution)</td></tr>
<tr class="memdesc:a2db7703ee0d4177478259e6f41d69549 inherit pub_methods_class_algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Este método se encarga de hacer un sumatorio de todas las distancias de los nodos que se encuentran en el vector que se pasa como argumento.  <a href="class_algorithm.html#a2db7703ee0d4177478259e6f41d69549">More...</a><br /></td></tr>
<tr class="separator:a2db7703ee0d4177478259e6f41d69549 inherit pub_methods_class_algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f1aad1909e1b1a78c354e92d16abc3 inherit pub_methods_class_algorithm"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm.html#a15f1aad1909e1b1a78c354e92d16abc3">getGravityCenter</a> (std::vector&lt; int &gt; currentElement)</td></tr>
<tr class="memdesc:a15f1aad1909e1b1a78c354e92d16abc3 inherit pub_methods_class_algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el valor del centro de gravedad del vector actual.  <a href="class_algorithm.html#a15f1aad1909e1b1a78c354e92d16abc3">More...</a><br /></td></tr>
<tr class="separator:a15f1aad1909e1b1a78c354e92d16abc3 inherit pub_methods_class_algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379b9bf8eb00aa7584d5537c6314197d inherit pub_methods_class_algorithm"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm.html#a379b9bf8eb00aa7584d5537c6314197d">getCandidates</a> (std::vector&lt; int &gt; checkSelected)</td></tr>
<tr class="memdesc:a379b9bf8eb00aa7584d5537c6314197d inherit pub_methods_class_algorithm"><td class="mdescLeft">&#160;</td><td class="mdescRight">Se encarga de determinar los candidatos a partir de un vector. Es decir, devuelve los elementos que no se encuentran en el vector que se pasa como parámetro.  <a href="class_algorithm.html#a379b9bf8eb00aa7584d5537c6314197d">More...</a><br /></td></tr>
<tr class="separator:a379b9bf8eb00aa7584d5537c6314197d inherit pub_methods_class_algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_class_algorithm"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_algorithm')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_algorithm.html">Algorithm</a></td></tr>
<tr class="memitem:a7438318d02e9af3a23a1971f7559682b inherit pro_attribs_class_algorithm"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vectors.html">Vectors</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_algorithm.html#a7438318d02e9af3a23a1971f7559682b">currentVectors</a></td></tr>
<tr class="separator:a7438318d02e9af3a23a1971f7559682b inherit pro_attribs_class_algorithm"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Representa una clase que va a aplicar el algoritmo de expansion y poda. </p>

<p class="definition">Definition at line <a class="el" href="branching-pruning-algorithm_8hpp_source.html#l00009">9</a> of file <a class="el" href="branching-pruning-algorithm_8hpp_source.html">branching-pruning-algorithm.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af5dd885c99c56c7e841e947d3a5042da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dd885c99c56c7e841e947d3a5042da">&#9670;&nbsp;</a></span>BranchingPruningAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BranchingPruningAlgorithm::BranchingPruningAlgorithm </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>newName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_solution.html">Solution</a>&#160;</td>
          <td class="paramname"><em>alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construye el algoritmo de ramificación y poda con un nombre, un valor m que representa el tamaño de la solucióm, una solución inicial de la que va a partir el algoritmo y un booleano que indica cual va a la función de exploración (cota mínima o profundidad). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newName</td><td>Representa el nombre del algoritmo </td></tr>
    <tr><td class="paramname">newM</td><td>Representa el valor del tamaño de la solución </td></tr>
    <tr><td class="paramname">alg</td><td>Solución que es obtenida de otro algoritmo que va a ser la solución inicial de este. </td></tr>
    <tr><td class="paramname">mode</td><td>Representa cual va a la función de exploración (cota mínima o profundidad). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="branching-pruning-algorithm_8cpp_source.html#l00013">13</a> of file <a class="el" href="branching-pruning-algorithm_8cpp_source.html">branching-pruning-algorithm.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0c5f31dfc1eb79130f55a7ca708380a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5f31dfc1eb79130f55a7ca708380a8">&#9670;&nbsp;</a></span>expand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BranchingPruningAlgorithm::expand </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeToExpand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funcion que se encarga de expandir el nodo que se ha seleccionado, para ello, pone el mismo a visitado y se pasa a generar los nodos hijos del mismo (teniendo en cuenta que partimos de la idea de que se ha implementado un arbol mejorado, es decir, impide que hayan nodos duplicados), creando cada nodo y añadiendolo al arbol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeToExpand</td><td>Representa el nodo elegido que se va a expander </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="branching-pruning-algorithm_8cpp_source.html#l00046">46</a> of file <a class="el" href="branching-pruning-algorithm_8cpp_source.html">branching-pruning-algorithm.cpp</a>.</p>

</div>
</div>
<a id="a252084974f86d1aadd4b916508a77d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252084974f86d1aadd4b916508a77d73">&#9670;&nbsp;</a></span>getMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BranchingPruningAlgorithm::getMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funcion que se encarga de determinar cual es el siguiente nodo a escoger para luego expandir, en el caso de que se den las condiciones. Depende de la función de exploración asignada, se hará con cota mínima o por profundidad. </p>
<dl class="section return"><dt>Returns</dt><dd>int Valor del nodo a escoger </dd></dl>

<p class="definition">Definition at line <a class="el" href="branching-pruning-algorithm_8cpp_source.html#l00192">192</a> of file <a class="el" href="branching-pruning-algorithm_8cpp_source.html">branching-pruning-algorithm.cpp</a>.</p>

</div>
</div>
<a id="ab9157bf2cff571f8dbfa6c794e880979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9157bf2cff571f8dbfa6c794e880979">&#9670;&nbsp;</a></span>getUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float BranchingPruningAlgorithm::getUpperBound </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>currentSolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Esta función se encarga de determinar la cota superior, para ello hay que tener en cuenta, que UPB2 va a formarse a partir de las p mejores aristas que est ́an entre sel y unsel y UPB3 van a ser las mejores aristas de unsel y unsel. Con esto en mente, sabemos que nuestra cota superior va a ser la suma de UPB2 Y UPB3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentSolution</td><td>Representa la solución parcial que tenemos en este momento y sobre la que se va a determinar la cota superior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float Representa el valor de la cota superior </dd></dl>

<p class="definition">Definition at line <a class="el" href="branching-pruning-algorithm_8cpp_source.html#l00073">73</a> of file <a class="el" href="branching-pruning-algorithm_8cpp_source.html">branching-pruning-algorithm.cpp</a>.</p>

</div>
</div>
<a id="a46f5de69f9f03aaf35267d17d454d0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f5de69f9f03aaf35267d17d454d0bd">&#9670;&nbsp;</a></span>initializeTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BranchingPruningAlgorithm::initializeTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Este método se encarga de inicializar el árbol, para ello se centra en crear los nodos que se encuentran en el primer nivel del arbol, añadiendolos al árbol. </p>

<p class="definition">Definition at line <a class="el" href="branching-pruning-algorithm_8cpp_source.html#l00027">27</a> of file <a class="el" href="branching-pruning-algorithm_8cpp_source.html">branching-pruning-algorithm.cpp</a>.</p>

</div>
</div>
<a id="ad80a8fba560dc660dd19925a7c83dadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80a8fba560dc660dd19925a7c83dadb">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_solution.html">Solution</a> BranchingPruningAlgorithm::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Función principal del algoritmo, esta se encarga de asignar la cota inferior al valor de la distancia de la solución inicial, inicializar el arbol e iterar en un bucle que se haya recorrido todo el árbol, en cada iteracion se determina el nodo con el menor valor y este se comprueba si mejora la solución, en caso de que lo haga y no esté visitado se expande. Si con la solución parcial actual, el valor de la distancia es superior a la cota inferior esta se actualiza. Además si se ha llegado al tamaño de la solución indicado se almacena dicha solución y retorna. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_solution.html" title="Representa una solucion, que va a contener el vector donde se almacena la misma , la media y luego el...">Solution</a> Representa la solución del algoritmo </dd></dl>

<p>Implements <a class="el" href="class_algorithm.html#a9ecc951b95131db9ea40b58c6605ac8b">Algorithm</a>.</p>

<p class="definition">Definition at line <a class="el" href="branching-pruning-algorithm_8cpp_source.html#l00150">150</a> of file <a class="el" href="branching-pruning-algorithm_8cpp_source.html">branching-pruning-algorithm.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="branching-pruning-algorithm_8hpp_source.html">branching-pruning-algorithm.hpp</a></li>
<li>src/<a class="el" href="branching-pruning-algorithm_8cpp_source.html">branching-pruning-algorithm.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_branching_pruning_algorithm.html">BranchingPruningAlgorithm</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
